{"version":3,"sources":["warn.ts"],"names":[],"mappings":";;AAAA,IAAI,gBAAgB,GAA8B,IAAI,CAAC;AAMvD;;;;;;;GAOG;AACH,0BACE,aAAqB,EACrB,KAAQ,EACR,cAA+B;IAE/B,GAAG,CAAC,CAAC,IAAM,QAAQ,IAAI,cAAc,CAAC,CAAC,CAAC;QACtC,EAAE,CAAC,CAAC,KAAK,IAAI,QAAQ,IAAI,KAAK,CAAC,CAAC,CAAC;YAC/B,IAAI,kBAAkB,GAAM,aAAa,mBAAc,QAAQ,wCAAqC,CAAC;YACrG,IAAM,mBAAmB,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;YAErD,EAAE,CAAC,CAAC,mBAAmB,CAAC,CAAC,CAAC;gBACxB,kBAAkB,IAAI,WAAS,mBAAmB,eAAY,CAAC;YACjE,CAAC;YACD,gBAAgB,CAAC,kBAAkB,CAAC,CAAC;QACvC,CAAC;IACH,CAAC;AACH,CAAC;AAhBD,4CAgBC;AAED;;;;;;GAMG;AACH,+BACE,aAAqB,EACrB,KAAQ,EACR,YAA6B;IAE7B,GAAG,CAAC,CAAC,IAAM,QAAQ,IAAI,YAAY,CAAC,CAAC,CAAC;QACpC,EAAE,CAAC,CAAC,KAAK,IAAI,QAAQ,IAAI,KAAK,IAAI,YAAY,CAAC,QAAQ,CAAC,IAAI,KAAK,CAAC,CAAC,CAAC;YAClE,gBAAgB,CACX,aAAa,mBAAc,QAAQ,sCAAiC,YAAY,CAAC,QAAQ,CAAC,6BAA0B,CACxH,CAAC;QACJ,CAAC;IACH,CAAC;AACH,CAAC;AAZD,sDAYC;AAED;;;GAGG;AACH,cAAqB,OAAe;IAClC,EAAE,CAAC,CAAC,OAAO,IAAI,OAAO,CAAC,IAAI,CAAC,CAAC,CAAC;QAC5B,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;IACxB,CAAC;AACH,CAAC;AAJD,oBAIC;AAED;;;;;GAKG;AACH,4BAAmC,eAA0C;IAC3E,gBAAgB,GAAG,eAAe,KAAK,SAAS,GAAG,IAAI,GAAG,eAAe,CAAC;AAC5E,CAAC;AAFD,gDAEC","file":"warn.js","sourcesContent":["let _warningCallback: (message: string) => void = warn;\n\nexport type ISettingsMap<T> = {\n  [P in keyof T]?: string;\n};\n\n/**\n * Warns when a deprecated props are being used.\n *\n * @param componentName - The name of the component being used.\n * @param props - The props passed into the component.\n * @param deprecationMap - The map of deprecations, where key is the prop name and the value is\n * either null or a replacement prop name.\n */\nexport function warnDeprecations<P>(\n  componentName: string,\n  props: P,\n  deprecationMap: ISettingsMap<P>): void {\n\n  for (const propName in deprecationMap) {\n    if (props && propName in props) {\n      let deprecationMessage = `${componentName} property '${propName}' was used but has been deprecated.`;\n      const replacementPropName = deprecationMap[propName];\n\n      if (replacementPropName) {\n        deprecationMessage += ` Use '${replacementPropName}' instead.`;\n      }\n      _warningCallback(deprecationMessage);\n    }\n  }\n}\n\n/**\n * Warns when two props which are mutually exclusive are both being used.\n *\n * @param componentName - The name of the component being used.\n * @param props - The props passed into the component.\n * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.\n */\nexport function warnMutuallyExclusive<P>(\n  componentName: string,\n  props: P,\n  exclusiveMap: ISettingsMap<P>): void {\n\n  for (const propName in exclusiveMap) {\n    if (props && propName in props && exclusiveMap[propName] in props) {\n      _warningCallback(\n        `${componentName} property '${propName}' is mutually exclusive with '${exclusiveMap[propName]}'. Use one or the other.`\n      );\n    }\n  }\n}\n\n/**\n * Sends a warning to console, if the api is present.\n * @param message - Warning message.\n */\nexport function warn(message: string): void {\n  if (console && console.warn) {\n    console.warn(message);\n  }\n}\n\n/**\n * Configures the warning callback. Passing in undefined will reset it to use the default\n * console.warn function.\n *\n * @param warningCallback - Callback to override the generated warnings.\n */\nexport function setWarningCallback(warningCallback: (message: string) => void): void {\n  _warningCallback = warningCallback === undefined ? warn : warningCallback;\n}\n"],"sourceRoot":"../src"}